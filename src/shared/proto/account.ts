// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v3.19.1
// source: account.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Empty, EmptyRequest, Metadata, String } from "./common";

export interface AuthStateChangedRequest {
  metadata?: Metadata | undefined;
  user?: UserInfo | undefined;
}

export interface AuthState {
  user?: UserInfo | undefined;
}

/** User's information */
export interface UserInfo {
  uid: string;
  displayName?: string | undefined;
  email?: string | undefined;
  photoUrl?: string | undefined;
}

export interface UserOrganization {
  active: boolean;
  memberId: string;
  name: string;
  organizationId: string;
  /** ["admin", "member", "owner"] */
  roles: string[];
}

export interface UserOrganizationsResponse {
  organizations: UserOrganization[];
}

export interface UserOrganizationUpdateRequest {
  organizationId?: string | undefined;
}

export interface UserCreditsData {
  balance?: UserCreditsBalance | undefined;
  usageTransactions: UsageTransaction[];
  paymentTransactions: PaymentTransaction[];
}

export interface GetOrganizationCreditsRequest {
  organizationId: string;
}

export interface OrganizationCreditsData {
  balance?: UserCreditsBalance | undefined;
  organizationId: string;
  usageTransactions: OrganizationUsageTransaction[];
}

export interface UserCreditsBalance {
  currentBalance: number;
}

export interface UsageTransaction {
  aiInferenceProviderName: string;
  aiModelName: string;
  aiModelTypeName: string;
  completionTokens: number;
  costUsd: number;
  createdAt: string;
  creditsUsed: number;
  generationId: string;
  organizationId: string;
  promptTokens: number;
  totalTokens: number;
  userId: string;
}

export interface PaymentTransaction {
  paidAt: string;
  creatorId: string;
  amountCents: number;
  credits: number;
}

export interface OrganizationUsageTransaction {
  aiInferenceProviderName: string;
  aiModelName: string;
  aiModelTypeName: string;
  completionTokens: number;
  costUsd: number;
  createdAt: string;
  creditsUsed: number;
  generationId: string;
  organizationId: string;
  promptTokens: number;
  totalTokens: number;
  userId: string;
}

function createBaseAuthStateChangedRequest(): AuthStateChangedRequest {
  return { metadata: undefined, user: undefined };
}

export const AuthStateChangedRequest: MessageFns<AuthStateChangedRequest> = {
  encode(message: AuthStateChangedRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metadata !== undefined) {
      Metadata.encode(message.metadata, writer.uint32(10).fork()).join();
    }
    if (message.user !== undefined) {
      UserInfo.encode(message.user, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthStateChangedRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthStateChangedRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.metadata = Metadata.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.user = UserInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthStateChangedRequest {
    return {
      metadata: isSet(object.metadata) ? Metadata.fromJSON(object.metadata) : undefined,
      user: isSet(object.user) ? UserInfo.fromJSON(object.user) : undefined,
    };
  },

  toJSON(message: AuthStateChangedRequest): unknown {
    const obj: any = {};
    if (message.metadata !== undefined) {
      obj.metadata = Metadata.toJSON(message.metadata);
    }
    if (message.user !== undefined) {
      obj.user = UserInfo.toJSON(message.user);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthStateChangedRequest>, I>>(base?: I): AuthStateChangedRequest {
    return AuthStateChangedRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthStateChangedRequest>, I>>(object: I): AuthStateChangedRequest {
    const message = createBaseAuthStateChangedRequest();
    message.metadata = (object.metadata !== undefined && object.metadata !== null)
      ? Metadata.fromPartial(object.metadata)
      : undefined;
    message.user = (object.user !== undefined && object.user !== null) ? UserInfo.fromPartial(object.user) : undefined;
    return message;
  },
};

function createBaseAuthState(): AuthState {
  return { user: undefined };
}

export const AuthState: MessageFns<AuthState> = {
  encode(message: AuthState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== undefined) {
      UserInfo.encode(message.user, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AuthState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAuthState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = UserInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AuthState {
    return { user: isSet(object.user) ? UserInfo.fromJSON(object.user) : undefined };
  },

  toJSON(message: AuthState): unknown {
    const obj: any = {};
    if (message.user !== undefined) {
      obj.user = UserInfo.toJSON(message.user);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AuthState>, I>>(base?: I): AuthState {
    return AuthState.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AuthState>, I>>(object: I): AuthState {
    const message = createBaseAuthState();
    message.user = (object.user !== undefined && object.user !== null) ? UserInfo.fromPartial(object.user) : undefined;
    return message;
  },
};

function createBaseUserInfo(): UserInfo {
  return { uid: "", displayName: undefined, email: undefined, photoUrl: undefined };
}

export const UserInfo: MessageFns<UserInfo> = {
  encode(message: UserInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.uid !== "") {
      writer.uint32(10).string(message.uid);
    }
    if (message.displayName !== undefined) {
      writer.uint32(18).string(message.displayName);
    }
    if (message.email !== undefined) {
      writer.uint32(26).string(message.email);
    }
    if (message.photoUrl !== undefined) {
      writer.uint32(34).string(message.photoUrl);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.uid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.photoUrl = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserInfo {
    return {
      uid: isSet(object.uid) ? globalThis.String(object.uid) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : undefined,
      email: isSet(object.email) ? globalThis.String(object.email) : undefined,
      photoUrl: isSet(object.photoUrl) ? globalThis.String(object.photoUrl) : undefined,
    };
  },

  toJSON(message: UserInfo): unknown {
    const obj: any = {};
    if (message.uid !== "") {
      obj.uid = message.uid;
    }
    if (message.displayName !== undefined) {
      obj.displayName = message.displayName;
    }
    if (message.email !== undefined) {
      obj.email = message.email;
    }
    if (message.photoUrl !== undefined) {
      obj.photoUrl = message.photoUrl;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserInfo>, I>>(base?: I): UserInfo {
    return UserInfo.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserInfo>, I>>(object: I): UserInfo {
    const message = createBaseUserInfo();
    message.uid = object.uid ?? "";
    message.displayName = object.displayName ?? undefined;
    message.email = object.email ?? undefined;
    message.photoUrl = object.photoUrl ?? undefined;
    return message;
  },
};

function createBaseUserOrganization(): UserOrganization {
  return { active: false, memberId: "", name: "", organizationId: "", roles: [] };
}

export const UserOrganization: MessageFns<UserOrganization> = {
  encode(message: UserOrganization, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.active !== false) {
      writer.uint32(8).bool(message.active);
    }
    if (message.memberId !== "") {
      writer.uint32(18).string(message.memberId);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.organizationId !== "") {
      writer.uint32(34).string(message.organizationId);
    }
    for (const v of message.roles) {
      writer.uint32(42).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserOrganization {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserOrganization();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.active = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.memberId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.organizationId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.roles.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserOrganization {
    return {
      active: isSet(object.active) ? globalThis.Boolean(object.active) : false,
      memberId: isSet(object.memberId) ? globalThis.String(object.memberId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      organizationId: isSet(object.organizationId) ? globalThis.String(object.organizationId) : "",
      roles: globalThis.Array.isArray(object?.roles) ? object.roles.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: UserOrganization): unknown {
    const obj: any = {};
    if (message.active !== false) {
      obj.active = message.active;
    }
    if (message.memberId !== "") {
      obj.memberId = message.memberId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.organizationId !== "") {
      obj.organizationId = message.organizationId;
    }
    if (message.roles?.length) {
      obj.roles = message.roles;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserOrganization>, I>>(base?: I): UserOrganization {
    return UserOrganization.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserOrganization>, I>>(object: I): UserOrganization {
    const message = createBaseUserOrganization();
    message.active = object.active ?? false;
    message.memberId = object.memberId ?? "";
    message.name = object.name ?? "";
    message.organizationId = object.organizationId ?? "";
    message.roles = object.roles?.map((e) => e) || [];
    return message;
  },
};

function createBaseUserOrganizationsResponse(): UserOrganizationsResponse {
  return { organizations: [] };
}

export const UserOrganizationsResponse: MessageFns<UserOrganizationsResponse> = {
  encode(message: UserOrganizationsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.organizations) {
      UserOrganization.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserOrganizationsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserOrganizationsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organizations.push(UserOrganization.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserOrganizationsResponse {
    return {
      organizations: globalThis.Array.isArray(object?.organizations)
        ? object.organizations.map((e: any) => UserOrganization.fromJSON(e))
        : [],
    };
  },

  toJSON(message: UserOrganizationsResponse): unknown {
    const obj: any = {};
    if (message.organizations?.length) {
      obj.organizations = message.organizations.map((e) => UserOrganization.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserOrganizationsResponse>, I>>(base?: I): UserOrganizationsResponse {
    return UserOrganizationsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserOrganizationsResponse>, I>>(object: I): UserOrganizationsResponse {
    const message = createBaseUserOrganizationsResponse();
    message.organizations = object.organizations?.map((e) => UserOrganization.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUserOrganizationUpdateRequest(): UserOrganizationUpdateRequest {
  return { organizationId: undefined };
}

export const UserOrganizationUpdateRequest: MessageFns<UserOrganizationUpdateRequest> = {
  encode(message: UserOrganizationUpdateRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organizationId !== undefined) {
      writer.uint32(10).string(message.organizationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserOrganizationUpdateRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserOrganizationUpdateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organizationId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserOrganizationUpdateRequest {
    return { organizationId: isSet(object.organizationId) ? globalThis.String(object.organizationId) : undefined };
  },

  toJSON(message: UserOrganizationUpdateRequest): unknown {
    const obj: any = {};
    if (message.organizationId !== undefined) {
      obj.organizationId = message.organizationId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserOrganizationUpdateRequest>, I>>(base?: I): UserOrganizationUpdateRequest {
    return UserOrganizationUpdateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserOrganizationUpdateRequest>, I>>(
    object: I,
  ): UserOrganizationUpdateRequest {
    const message = createBaseUserOrganizationUpdateRequest();
    message.organizationId = object.organizationId ?? undefined;
    return message;
  },
};

function createBaseUserCreditsData(): UserCreditsData {
  return { balance: undefined, usageTransactions: [], paymentTransactions: [] };
}

export const UserCreditsData: MessageFns<UserCreditsData> = {
  encode(message: UserCreditsData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.balance !== undefined) {
      UserCreditsBalance.encode(message.balance, writer.uint32(10).fork()).join();
    }
    for (const v of message.usageTransactions) {
      UsageTransaction.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.paymentTransactions) {
      PaymentTransaction.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserCreditsData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserCreditsData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.balance = UserCreditsBalance.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.usageTransactions.push(UsageTransaction.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.paymentTransactions.push(PaymentTransaction.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserCreditsData {
    return {
      balance: isSet(object.balance) ? UserCreditsBalance.fromJSON(object.balance) : undefined,
      usageTransactions: globalThis.Array.isArray(object?.usageTransactions)
        ? object.usageTransactions.map((e: any) => UsageTransaction.fromJSON(e))
        : [],
      paymentTransactions: globalThis.Array.isArray(object?.paymentTransactions)
        ? object.paymentTransactions.map((e: any) => PaymentTransaction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: UserCreditsData): unknown {
    const obj: any = {};
    if (message.balance !== undefined) {
      obj.balance = UserCreditsBalance.toJSON(message.balance);
    }
    if (message.usageTransactions?.length) {
      obj.usageTransactions = message.usageTransactions.map((e) => UsageTransaction.toJSON(e));
    }
    if (message.paymentTransactions?.length) {
      obj.paymentTransactions = message.paymentTransactions.map((e) => PaymentTransaction.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserCreditsData>, I>>(base?: I): UserCreditsData {
    return UserCreditsData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserCreditsData>, I>>(object: I): UserCreditsData {
    const message = createBaseUserCreditsData();
    message.balance = (object.balance !== undefined && object.balance !== null)
      ? UserCreditsBalance.fromPartial(object.balance)
      : undefined;
    message.usageTransactions = object.usageTransactions?.map((e) => UsageTransaction.fromPartial(e)) || [];
    message.paymentTransactions = object.paymentTransactions?.map((e) => PaymentTransaction.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetOrganizationCreditsRequest(): GetOrganizationCreditsRequest {
  return { organizationId: "" };
}

export const GetOrganizationCreditsRequest: MessageFns<GetOrganizationCreditsRequest> = {
  encode(message: GetOrganizationCreditsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.organizationId !== "") {
      writer.uint32(10).string(message.organizationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetOrganizationCreditsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetOrganizationCreditsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.organizationId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetOrganizationCreditsRequest {
    return { organizationId: isSet(object.organizationId) ? globalThis.String(object.organizationId) : "" };
  },

  toJSON(message: GetOrganizationCreditsRequest): unknown {
    const obj: any = {};
    if (message.organizationId !== "") {
      obj.organizationId = message.organizationId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetOrganizationCreditsRequest>, I>>(base?: I): GetOrganizationCreditsRequest {
    return GetOrganizationCreditsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetOrganizationCreditsRequest>, I>>(
    object: I,
  ): GetOrganizationCreditsRequest {
    const message = createBaseGetOrganizationCreditsRequest();
    message.organizationId = object.organizationId ?? "";
    return message;
  },
};

function createBaseOrganizationCreditsData(): OrganizationCreditsData {
  return { balance: undefined, organizationId: "", usageTransactions: [] };
}

export const OrganizationCreditsData: MessageFns<OrganizationCreditsData> = {
  encode(message: OrganizationCreditsData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.balance !== undefined) {
      UserCreditsBalance.encode(message.balance, writer.uint32(10).fork()).join();
    }
    if (message.organizationId !== "") {
      writer.uint32(18).string(message.organizationId);
    }
    for (const v of message.usageTransactions) {
      OrganizationUsageTransaction.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrganizationCreditsData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrganizationCreditsData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.balance = UserCreditsBalance.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.organizationId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.usageTransactions.push(OrganizationUsageTransaction.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrganizationCreditsData {
    return {
      balance: isSet(object.balance) ? UserCreditsBalance.fromJSON(object.balance) : undefined,
      organizationId: isSet(object.organizationId) ? globalThis.String(object.organizationId) : "",
      usageTransactions: globalThis.Array.isArray(object?.usageTransactions)
        ? object.usageTransactions.map((e: any) => OrganizationUsageTransaction.fromJSON(e))
        : [],
    };
  },

  toJSON(message: OrganizationCreditsData): unknown {
    const obj: any = {};
    if (message.balance !== undefined) {
      obj.balance = UserCreditsBalance.toJSON(message.balance);
    }
    if (message.organizationId !== "") {
      obj.organizationId = message.organizationId;
    }
    if (message.usageTransactions?.length) {
      obj.usageTransactions = message.usageTransactions.map((e) => OrganizationUsageTransaction.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrganizationCreditsData>, I>>(base?: I): OrganizationCreditsData {
    return OrganizationCreditsData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrganizationCreditsData>, I>>(object: I): OrganizationCreditsData {
    const message = createBaseOrganizationCreditsData();
    message.balance = (object.balance !== undefined && object.balance !== null)
      ? UserCreditsBalance.fromPartial(object.balance)
      : undefined;
    message.organizationId = object.organizationId ?? "";
    message.usageTransactions = object.usageTransactions?.map((e) => OrganizationUsageTransaction.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUserCreditsBalance(): UserCreditsBalance {
  return { currentBalance: 0 };
}

export const UserCreditsBalance: MessageFns<UserCreditsBalance> = {
  encode(message: UserCreditsBalance, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.currentBalance !== 0) {
      writer.uint32(9).double(message.currentBalance);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserCreditsBalance {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserCreditsBalance();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.currentBalance = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserCreditsBalance {
    return { currentBalance: isSet(object.currentBalance) ? globalThis.Number(object.currentBalance) : 0 };
  },

  toJSON(message: UserCreditsBalance): unknown {
    const obj: any = {};
    if (message.currentBalance !== 0) {
      obj.currentBalance = message.currentBalance;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserCreditsBalance>, I>>(base?: I): UserCreditsBalance {
    return UserCreditsBalance.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserCreditsBalance>, I>>(object: I): UserCreditsBalance {
    const message = createBaseUserCreditsBalance();
    message.currentBalance = object.currentBalance ?? 0;
    return message;
  },
};

function createBaseUsageTransaction(): UsageTransaction {
  return {
    aiInferenceProviderName: "",
    aiModelName: "",
    aiModelTypeName: "",
    completionTokens: 0,
    costUsd: 0,
    createdAt: "",
    creditsUsed: 0,
    generationId: "",
    organizationId: "",
    promptTokens: 0,
    totalTokens: 0,
    userId: "",
  };
}

export const UsageTransaction: MessageFns<UsageTransaction> = {
  encode(message: UsageTransaction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.aiInferenceProviderName !== "") {
      writer.uint32(10).string(message.aiInferenceProviderName);
    }
    if (message.aiModelName !== "") {
      writer.uint32(18).string(message.aiModelName);
    }
    if (message.aiModelTypeName !== "") {
      writer.uint32(26).string(message.aiModelTypeName);
    }
    if (message.completionTokens !== 0) {
      writer.uint32(32).int32(message.completionTokens);
    }
    if (message.costUsd !== 0) {
      writer.uint32(41).double(message.costUsd);
    }
    if (message.createdAt !== "") {
      writer.uint32(50).string(message.createdAt);
    }
    if (message.creditsUsed !== 0) {
      writer.uint32(57).double(message.creditsUsed);
    }
    if (message.generationId !== "") {
      writer.uint32(66).string(message.generationId);
    }
    if (message.organizationId !== "") {
      writer.uint32(74).string(message.organizationId);
    }
    if (message.promptTokens !== 0) {
      writer.uint32(80).int32(message.promptTokens);
    }
    if (message.totalTokens !== 0) {
      writer.uint32(88).int32(message.totalTokens);
    }
    if (message.userId !== "") {
      writer.uint32(98).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UsageTransaction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUsageTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.aiInferenceProviderName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.aiModelName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.aiModelTypeName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.completionTokens = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.costUsd = reader.double();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 57) {
            break;
          }

          message.creditsUsed = reader.double();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.generationId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.organizationId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.promptTokens = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.totalTokens = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UsageTransaction {
    return {
      aiInferenceProviderName: isSet(object.aiInferenceProviderName)
        ? globalThis.String(object.aiInferenceProviderName)
        : "",
      aiModelName: isSet(object.aiModelName) ? globalThis.String(object.aiModelName) : "",
      aiModelTypeName: isSet(object.aiModelTypeName) ? globalThis.String(object.aiModelTypeName) : "",
      completionTokens: isSet(object.completionTokens) ? globalThis.Number(object.completionTokens) : 0,
      costUsd: isSet(object.costUsd) ? globalThis.Number(object.costUsd) : 0,
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      creditsUsed: isSet(object.creditsUsed) ? globalThis.Number(object.creditsUsed) : 0,
      generationId: isSet(object.generationId) ? globalThis.String(object.generationId) : "",
      organizationId: isSet(object.organizationId) ? globalThis.String(object.organizationId) : "",
      promptTokens: isSet(object.promptTokens) ? globalThis.Number(object.promptTokens) : 0,
      totalTokens: isSet(object.totalTokens) ? globalThis.Number(object.totalTokens) : 0,
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
    };
  },

  toJSON(message: UsageTransaction): unknown {
    const obj: any = {};
    if (message.aiInferenceProviderName !== "") {
      obj.aiInferenceProviderName = message.aiInferenceProviderName;
    }
    if (message.aiModelName !== "") {
      obj.aiModelName = message.aiModelName;
    }
    if (message.aiModelTypeName !== "") {
      obj.aiModelTypeName = message.aiModelTypeName;
    }
    if (message.completionTokens !== 0) {
      obj.completionTokens = Math.round(message.completionTokens);
    }
    if (message.costUsd !== 0) {
      obj.costUsd = message.costUsd;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.creditsUsed !== 0) {
      obj.creditsUsed = message.creditsUsed;
    }
    if (message.generationId !== "") {
      obj.generationId = message.generationId;
    }
    if (message.organizationId !== "") {
      obj.organizationId = message.organizationId;
    }
    if (message.promptTokens !== 0) {
      obj.promptTokens = Math.round(message.promptTokens);
    }
    if (message.totalTokens !== 0) {
      obj.totalTokens = Math.round(message.totalTokens);
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UsageTransaction>, I>>(base?: I): UsageTransaction {
    return UsageTransaction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UsageTransaction>, I>>(object: I): UsageTransaction {
    const message = createBaseUsageTransaction();
    message.aiInferenceProviderName = object.aiInferenceProviderName ?? "";
    message.aiModelName = object.aiModelName ?? "";
    message.aiModelTypeName = object.aiModelTypeName ?? "";
    message.completionTokens = object.completionTokens ?? 0;
    message.costUsd = object.costUsd ?? 0;
    message.createdAt = object.createdAt ?? "";
    message.creditsUsed = object.creditsUsed ?? 0;
    message.generationId = object.generationId ?? "";
    message.organizationId = object.organizationId ?? "";
    message.promptTokens = object.promptTokens ?? 0;
    message.totalTokens = object.totalTokens ?? 0;
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBasePaymentTransaction(): PaymentTransaction {
  return { paidAt: "", creatorId: "", amountCents: 0, credits: 0 };
}

export const PaymentTransaction: MessageFns<PaymentTransaction> = {
  encode(message: PaymentTransaction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.paidAt !== "") {
      writer.uint32(10).string(message.paidAt);
    }
    if (message.creatorId !== "") {
      writer.uint32(18).string(message.creatorId);
    }
    if (message.amountCents !== 0) {
      writer.uint32(24).int32(message.amountCents);
    }
    if (message.credits !== 0) {
      writer.uint32(33).double(message.credits);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PaymentTransaction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePaymentTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.paidAt = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.creatorId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.amountCents = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.credits = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PaymentTransaction {
    return {
      paidAt: isSet(object.paidAt) ? globalThis.String(object.paidAt) : "",
      creatorId: isSet(object.creatorId) ? globalThis.String(object.creatorId) : "",
      amountCents: isSet(object.amountCents) ? globalThis.Number(object.amountCents) : 0,
      credits: isSet(object.credits) ? globalThis.Number(object.credits) : 0,
    };
  },

  toJSON(message: PaymentTransaction): unknown {
    const obj: any = {};
    if (message.paidAt !== "") {
      obj.paidAt = message.paidAt;
    }
    if (message.creatorId !== "") {
      obj.creatorId = message.creatorId;
    }
    if (message.amountCents !== 0) {
      obj.amountCents = Math.round(message.amountCents);
    }
    if (message.credits !== 0) {
      obj.credits = message.credits;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PaymentTransaction>, I>>(base?: I): PaymentTransaction {
    return PaymentTransaction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PaymentTransaction>, I>>(object: I): PaymentTransaction {
    const message = createBasePaymentTransaction();
    message.paidAt = object.paidAt ?? "";
    message.creatorId = object.creatorId ?? "";
    message.amountCents = object.amountCents ?? 0;
    message.credits = object.credits ?? 0;
    return message;
  },
};

function createBaseOrganizationUsageTransaction(): OrganizationUsageTransaction {
  return {
    aiInferenceProviderName: "",
    aiModelName: "",
    aiModelTypeName: "",
    completionTokens: 0,
    costUsd: 0,
    createdAt: "",
    creditsUsed: 0,
    generationId: "",
    organizationId: "",
    promptTokens: 0,
    totalTokens: 0,
    userId: "",
  };
}

export const OrganizationUsageTransaction: MessageFns<OrganizationUsageTransaction> = {
  encode(message: OrganizationUsageTransaction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.aiInferenceProviderName !== "") {
      writer.uint32(10).string(message.aiInferenceProviderName);
    }
    if (message.aiModelName !== "") {
      writer.uint32(18).string(message.aiModelName);
    }
    if (message.aiModelTypeName !== "") {
      writer.uint32(26).string(message.aiModelTypeName);
    }
    if (message.completionTokens !== 0) {
      writer.uint32(32).int32(message.completionTokens);
    }
    if (message.costUsd !== 0) {
      writer.uint32(41).double(message.costUsd);
    }
    if (message.createdAt !== "") {
      writer.uint32(50).string(message.createdAt);
    }
    if (message.creditsUsed !== 0) {
      writer.uint32(57).double(message.creditsUsed);
    }
    if (message.generationId !== "") {
      writer.uint32(66).string(message.generationId);
    }
    if (message.organizationId !== "") {
      writer.uint32(74).string(message.organizationId);
    }
    if (message.promptTokens !== 0) {
      writer.uint32(80).int32(message.promptTokens);
    }
    if (message.totalTokens !== 0) {
      writer.uint32(88).int32(message.totalTokens);
    }
    if (message.userId !== "") {
      writer.uint32(98).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OrganizationUsageTransaction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOrganizationUsageTransaction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.aiInferenceProviderName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.aiModelName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.aiModelTypeName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.completionTokens = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.costUsd = reader.double();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 57) {
            break;
          }

          message.creditsUsed = reader.double();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.generationId = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.organizationId = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.promptTokens = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.totalTokens = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OrganizationUsageTransaction {
    return {
      aiInferenceProviderName: isSet(object.aiInferenceProviderName)
        ? globalThis.String(object.aiInferenceProviderName)
        : "",
      aiModelName: isSet(object.aiModelName) ? globalThis.String(object.aiModelName) : "",
      aiModelTypeName: isSet(object.aiModelTypeName) ? globalThis.String(object.aiModelTypeName) : "",
      completionTokens: isSet(object.completionTokens) ? globalThis.Number(object.completionTokens) : 0,
      costUsd: isSet(object.costUsd) ? globalThis.Number(object.costUsd) : 0,
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      creditsUsed: isSet(object.creditsUsed) ? globalThis.Number(object.creditsUsed) : 0,
      generationId: isSet(object.generationId) ? globalThis.String(object.generationId) : "",
      organizationId: isSet(object.organizationId) ? globalThis.String(object.organizationId) : "",
      promptTokens: isSet(object.promptTokens) ? globalThis.Number(object.promptTokens) : 0,
      totalTokens: isSet(object.totalTokens) ? globalThis.Number(object.totalTokens) : 0,
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
    };
  },

  toJSON(message: OrganizationUsageTransaction): unknown {
    const obj: any = {};
    if (message.aiInferenceProviderName !== "") {
      obj.aiInferenceProviderName = message.aiInferenceProviderName;
    }
    if (message.aiModelName !== "") {
      obj.aiModelName = message.aiModelName;
    }
    if (message.aiModelTypeName !== "") {
      obj.aiModelTypeName = message.aiModelTypeName;
    }
    if (message.completionTokens !== 0) {
      obj.completionTokens = Math.round(message.completionTokens);
    }
    if (message.costUsd !== 0) {
      obj.costUsd = message.costUsd;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.creditsUsed !== 0) {
      obj.creditsUsed = message.creditsUsed;
    }
    if (message.generationId !== "") {
      obj.generationId = message.generationId;
    }
    if (message.organizationId !== "") {
      obj.organizationId = message.organizationId;
    }
    if (message.promptTokens !== 0) {
      obj.promptTokens = Math.round(message.promptTokens);
    }
    if (message.totalTokens !== 0) {
      obj.totalTokens = Math.round(message.totalTokens);
    }
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OrganizationUsageTransaction>, I>>(base?: I): OrganizationUsageTransaction {
    return OrganizationUsageTransaction.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OrganizationUsageTransaction>, I>>(object: I): OrganizationUsageTransaction {
    const message = createBaseOrganizationUsageTransaction();
    message.aiInferenceProviderName = object.aiInferenceProviderName ?? "";
    message.aiModelName = object.aiModelName ?? "";
    message.aiModelTypeName = object.aiModelTypeName ?? "";
    message.completionTokens = object.completionTokens ?? 0;
    message.costUsd = object.costUsd ?? 0;
    message.createdAt = object.createdAt ?? "";
    message.creditsUsed = object.creditsUsed ?? 0;
    message.generationId = object.generationId ?? "";
    message.organizationId = object.organizationId ?? "";
    message.promptTokens = object.promptTokens ?? 0;
    message.totalTokens = object.totalTokens ?? 0;
    message.userId = object.userId ?? "";
    return message;
  },
};

/** Service for account-related operations */
export type AccountServiceDefinition = typeof AccountServiceDefinition;
export const AccountServiceDefinition = {
  name: "AccountService",
  fullName: "cline.AccountService",
  methods: {
    /**
     * Handles the user clicking the login link in the UI.
     * Generates a secure nonce for state validation, stores it in secrets,
     * and opens the authentication URL in the external browser.
     */
    accountLoginClicked: {
      name: "accountLoginClicked",
      requestType: EmptyRequest,
      requestStream: false,
      responseType: String,
      responseStream: false,
      options: {},
    },
    /**
     * Handles the user clicking the logout button in the UI.
     * Clears API keys and user state.
     */
    accountLogoutClicked: {
      name: "accountLogoutClicked",
      requestType: EmptyRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
    /** Subscribe to auth status update events (when authentication state changes) */
    subscribeToAuthStatusUpdate: {
      name: "subscribeToAuthStatusUpdate",
      requestType: EmptyRequest,
      requestStream: false,
      responseType: AuthState,
      responseStream: true,
      options: {},
    },
    /**
     * Handles authentication state changes from the Firebase context.
     * Updates the user info in global state and returns the updated value.
     */
    authStateChanged: {
      name: "authStateChanged",
      requestType: AuthStateChangedRequest,
      requestStream: false,
      responseType: AuthState,
      responseStream: false,
      options: {},
    },
    /**
     * Fetches all user credits data
     * (balance, usage transactions, payment transactions)
     */
    getUserCredits: {
      name: "getUserCredits",
      requestType: EmptyRequest,
      requestStream: false,
      responseType: UserCreditsData,
      responseStream: false,
      options: {},
    },
    getOrganizationCredits: {
      name: "getOrganizationCredits",
      requestType: GetOrganizationCreditsRequest,
      requestStream: false,
      responseType: OrganizationCreditsData,
      responseStream: false,
      options: {},
    },
    /**
     * Fetches all user organizations data
     * Returns a list of UserOrganization objects
     */
    getUserOrganizations: {
      name: "getUserOrganizations",
      requestType: EmptyRequest,
      requestStream: false,
      responseType: UserOrganizationsResponse,
      responseStream: false,
      options: {},
    },
    setUserOrganization: {
      name: "setUserOrganization",
      requestType: UserOrganizationUpdateRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
  },
} as const;

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
